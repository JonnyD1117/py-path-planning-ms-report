\section{Conclusions}

From the results tabulated above, it's evident that there exists measurable performance differences between each of the planner covered in this paper. In particular, it should be noted that the A* and Dijkstra's algorithms produce deterministic output paths given the same input map. This is shown by the identical path cost between these two planners, both with zero variance between trials. However, an even more interesting result is the difference in computation time. While A* and Dijkstra's algorithms produce the same path the incorporation of a heuristic to A* significantly reduces the time it takes to compute a solution. This is one of many reasons why A* has long been the defacto standard. 

There is one point of subtlety in the tabulated results for A* and Dijkstra that should be accounted for. While both algorithms will deterministically produce the same path (if given the same graph and start/stop locations), the compute time for each of these is not deterministic. The reason for this determinism in the path generation is purely based on algorithmic construction. Both algorithms do not incorporate any form of stochastic approximation or sampling that would provide any variance in the path being generated. The only algorithmic difference are related to the search efficiency each employs. Even so, both search algorithms are deterministic in nature. On the other hand, the compute time is stochastic due to the nature of process management on a modern computer operating system. The operating system of a modern computer is a complex and involved program that manages and maintains all of the programs that are currently running as processes on a CPU. This involves load balancing the CPU cores, managing calls for input(s)/output(s) ... etc. Even if the program being run is deterministic in nature, the process management being performed by the operating system is not. Additionally, CPU performance can also vary depending on operating conditions (e.g. CPU temperatures), which could cause the compute times to drift when running performance tests sequentially when developing statistical averages. 


Moving on, PRM and A* take the least amount of time to compute a viable solution, when given the same input map. Unlike A*, PRM's use of random sampling means that the output path is not deterministic which explains the variance its is path cost. However, while PRM under performs when compared to A*, it is significantly more performant than the remaining algorithms. This could likely be due to the fact that PRM uses Dijkstra's algorithm to compute the shortest path once it has completed the graph generation process. Switching this algorithm to A*, might even conceivably produce better performance than pure A* as the typical PRM graph is far less dense than the grid map which A* searches. 

By far the worst performing algorithm is RRT. In both compute time and path cost, the standard implementation of RRT performs terribly. This is partly due to the sample efficiency of tree generation, but is mostly due to the fact that RRT cannot rewire its tree structure to minimize the path, during tree generation. This results in extremely circuitous paths being locked into the tree structure. Even if new samples are generated that would (globally) reduce the path cost of the tree, RRT does not implement any mechanism for disconnecting certain branches and reconnecting them to others to improve the path cost. This means that RRT will only ever increase the path cost beyond the optimal value. These problems are addressed in more recent variants of RRT such as RRT* that optimizes its sampled tree as its being generated. This is also a technique borrowed by other algorithms like PRM* to accomplish the same behavior and trend towards the optimal path as the number of sampled points trends to infinity. 